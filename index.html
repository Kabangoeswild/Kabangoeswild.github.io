<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AR.js Multi-Marker with Video</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/three.js/build/ar-threex.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/build/three.min.js"></script>
  <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
<script>
  let scene, camera, renderer;
  let arToolkitSource, arToolkitContext;
  let markerRoot, smoothedRoot;

  // Init
  init();
  animate();

  async function init() {
    // Scene setup
    scene = new THREE.Scene();
    camera = new THREE.Camera();
    scene.add(camera);

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Source
    arToolkitSource = new THREEx.ArToolkitSource({ sourceType: 'webcam' });
    arToolkitSource.init(() => onResize());
    window.addEventListener('resize', () => onResize());

    // Context
    arToolkitContext = new THREEx.ArToolkitContext({
      cameraParametersUrl: 'https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/data/data/camera_para.dat',
      detectionMode: 'mono'
    });

    await new Promise(resolve => arToolkitContext.init(() => {
      camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
      resolve();
    }));

    // Update loop
    onRenderFcts.push(() => {
      if (arToolkitSource.ready) arToolkitContext.update(arToolkitSource.domElement);
    });

    // Load Multi-Marker JSON
    const multiMarkerFile = await fetch('multi-marker.json').then(res => res.json());
    markerRoot = new THREE.Group();
    scene.add(markerRoot);

    const multiMarkerControls = THREEx.ArMultiMarkerControls.fromJSON(
      arToolkitContext, scene, markerRoot, multiMarkerFile
    );

    // Compute center
    smoothedRoot = new THREE.Group();
    scene.add(smoothedRoot);

    let averageMatrix = THREEx.ArMultiMarkerControls.computeCenter(multiMarkerFile);
    averageMatrix.decompose(smoothedRoot.position, smoothedRoot.quaternion, smoothedRoot.scale);

    // VIDEO OBJECT
    const video = document.createElement('video');
    video.src = 'yz x -0.35.mp4';
    video.crossOrigin = 'anonymous';
    video.loop = true;
    video.muted = true;
    video.play();

    const texture = new THREE.VideoTexture(video);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;

    const geometry = new THREE.PlaneGeometry(1.5, 1);
    const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.rotation.x = -Math.PI / 2; // Rotate so it's flat
    smoothedRoot.add(mesh);

    // Update smoothed transform
    onRenderFcts.push(() => {
      multiMarkerControls.updateSmoothedControls(smoothedRoot);
    });
  }

  // Resize
  function onResize() {
    arToolkitSource.onResizeElement();
    arToolkitSource.copyElementSizeTo(renderer.domElement);
    if (arToolkitContext.arController) {
      arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas);
    }
  }

  // Animation
  let onRenderFcts = [];
  function animate(now) {
    requestAnimationFrame(animate);
    onRenderFcts.forEach(f => f());
    renderer.render(scene, camera);
  }
</script>
</body>
</html>


